# 자바스크립트 개요
https://developer.mozilla.org/en-US/docs/Learn/JavaScript
https://academind.com/tutorialsf

# 핵심 구문 복습
01-core-js-syntax.zip  
[JavaScript from Scratch-자바스크립트 처음부터 배우기](https://developer.mozilla.org/en-US/docs/Learn/JavaScript)  
[Various JavaScript Beginner Resources-다양한 자바스크립트 초보자 리소스](https://academind.com/tutorials/)  
[Primitive vs Reference Types-프리미티브 유형과 참조 유형](https://academind.com/tutorials/)  

# let & const
02-let-and-const.zip

# 화살표 함수의 이해
03-arrow-functions.zip
[Arrow Functions and "this"](https://academind.com/tutorials/)  

# 개체, 속성 및 메서드 작업
[Primitive vs Reference Types](https://academind.com/tutorials/reference-vs-primitive-values)

# 배열과 배열 메서드
[Available Array Properties & Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#)

# 배역, 객체 및 참조 유형
[
현대의 JavaScript에는  
반드시 알아야 하는 두 개의 연산자가 있고  
강의에서도 계속 사용할 예정입니다  
바로 레스트(Rest)와 스프레드(Spread) 연산자입니다, 구체적으로 들어가서  
레스트 연산자는 꽤 자주 사용하게 될 것입니다  
새로운 hobby를 추가할 때마다 기존의 배열을  
편집하고 싶지 않다고 해보겠습니다  
대신 기존 값과 새로운 값이 모두 포함된 새로운 배열을 만들고 싶다고 해보겠습니다  
이는 불변성이라 불리며 꽤 자주 등장하는 패턴입니다  
기존의 값을 절대 편집하지 않고  
사본에 변경된 값을 더한 배열로 대체하는 방식입니다  
이 강의에서 자주 사용하게 될 패턴입니다  
복사해서 편집함으로 오류를 피할 수 있고  
기존 객체를 편집하지 않음으로써  
코드를 읽어올 수 없게 되는 일을 방지할 수 있습니다  
배열을 복사하려면 여기 copiedArray를 생성합니다  
몇 가지 기법이 있습니다  
하나는 슬라이스 연산자를 사용하는 것으로  
여기에 copiedArray를 입력하고 node play.js를 실행하면 Sports와 Cooking이 보입니다  
복사되었음을 볼 수 있습니다  
slice는 배열을 복사합니다  
인수를 입력해서 복사하길 원하는 원소의 범위를 제한할 수 있습니다  
인수가 없으면 배열 전체가 복사됩니다  
slice 외에 다른 기법도 있습니다  
대괄호로 새로운 배열을 만들고  
hobbies를 추가해도 됩니다  
이를 실행하면 어떻게 될까요?  
콘솔에 무엇이 표시되는지 보겠습니다  
Enter를 누르면 사본처럼 보입니다 그러나 실제로는 배열 안에  
또 다른 배열이 있는 겁니다  
외부 배열에 하나의 원소만이 있고 그 원소가 바로 내부 배열입니다  
따라서 사본이 아니라 첫 원소가 기존의 배열인 새로운 배열일 뿐입니다  
이는 사본이 아니라 완전히 동일한 객체를 의미합니다  
따라서 우리가 만든 것은  
중첩 배열로 이는 원하던 작업이 아닙니다  
여기서 사용 가능한 스프레드 연산자는 배열 또는  
객체 앞에 추가하는 점 세 개입니다  
이 점 세 개는 +나 -와 같은 연산자로  
연산자 뒤에 오는  
배열이나 객체를 받아서  
원소나 속성을 끄집어냅니다  
따라서 배열의 원소나 객체의 속성을  
스프레드 연산자 주위에 있는 대상에 추가합니다  
이 경우에는 스프레드 연산자에 대괄호가 씌워져 있으므로  
기존의 배열에서 끄집어낸 모든 원소를  
새로운 배열에 추가해 줍니다  
따라서 이 파일을 저장하고 다시 실행하면  
기존 접근법의 중첩 배열이 있던 곳에  
중첩 배열이 없어졌습니다  
대신 배열 하나가 있고 이 배열은 기존 배열의 사본입니다  
스프레드 연산자로 원소를 끄집어내서  
새로운 배열에 하나씩 추가했기 때문입니다  
기존의 배열이나 객체에 이러한 작업을 많이 하게 될 것입니다  
객체에서도 같은 방식으로 작동합니다  
중괄호로 copiedPerson을 만들고 스프레드 연산자를  
점 세 개로 입력하고 기존의 Person을 입력합니다  
이제 copiedPerson을 console.log 하고  
이 파일을 다시 실행하면  
여기에 person의 사본이 나타납니다 객체의 원소를 모두 추출해서  
새로운 객체에 추가했기 때문입니다  
이는 객체와 배열 모두에 적용 가능합니다 그리고 이 구문을  
이 강의에서 자주 사용하겠습니다  
이게 바로 스프레드 연산자입니다  
레스트 연산자도 언급했는데 레스트 연산자는 정 반대입니다  
toArray라는 이름의 화살표 함수가 있다고 해보겠습니다  
arg1, arg2, arg3 인수가 있습니다  
이 인수들을 포함한 배열을 반환하도록 하고 싶습니다  
여기에 등호를 추가해 줍니다  
이 인수들을 포함한 배열을 반환하게 하고자 합니다  
return 대괄호를 입력하고 첫 번째 원소는 arg1,  
두 번째 원소는 arg2, 세 번째 원소는 arg3로 하면 됩니다  
이제 console.log (toArray)를 입력하고  
1, 2, 3,을 각각 인수로 함수에 입력한 다음  
play.js를 실행하면 1, 2, 3 세 개의 원소가 포함된 배열이 보입니다  
제대로 됐습니다 그러나 이는 전혀 유연하지 않습니다  
네 개의 인수를 입력하고 싶다면  
이렇게 호출할 수도 있습니다  
JavaScript는 이를 허용합니다  
그러나 세 개의 인수만으로 작업했기 때문에 추가되지는 않습니다  
이럴 때 레스트 연산자를 활용할 수 있습니다  
... 뒤에 args를 입력합니다  
이렇게 하면 개수에 관계없이  
모든 인수를 가지고 와서  
하나의 배열로 나타냅니다  
여기서 args는 배열이 되며 이를 반환하게 할 수 있습니다  
이제 toArray에 4개의 인수를  
입력하고 다시 실행하면 이제 4개의 인수가 있는  
배열을 얻을 수 있습니다 레스트 연산자는 스프레드 연산자처럼  
세 개의 점으로 되어있으며 사용하는 위치에 따라 정의가 달라집니다  
배열이나 객체에서 원소나 속성을 추출하는 데 사용한다면  
스프레드 연산자입니다  
인수 목록이나 함수에서  
여러 인수를 하나의 배열로 묶는데 사용한다면  
레스트 연산자입니다  
구문으로 보면 동일한 연산자이지만  
사용하는 위치에 따라 이름이 달라집니다  
이 구문은 강의에서 자주 사용하지는 않겠지만 그래도 알아두면 좋습니다  
그러나 원소 또는 속성 추출은 반드시 이해해야 합니다  
이 강의 전반에 걸쳐서  
자주 사용할 구문이기 때문입니다
]

# 스프레드(Spread) 및 레스트(Rest) 연산자의 이해
[차이점](https://chat.openai.com/c/4851a6d4-70ee-4c6f-b7ce-03c93a7efd7b)  

# Destructuring (구조분해)
[배열과 객체의 구조분해, 객체를 인자로 받는 함수에서의 구조분해](https://chat.openai.com/c/2fbe5a80-9873-40cd-85eb-05e1efe6cc49)

# 비동기 코드와 프로미스
[  
다시 play.js 파일을 지웠습니다  
빠르게 복습 모듈을 마치고 다른 핵심 개념인  
비동기화 코드를 다루는 방법을 배우기 위해서입니다  
이를 위해 먼저 비동기화 코드가 무엇인지부터 이해해야 합니다  
Node.js에 구축되어 있는 함수인 타이머 종료 시간을 설정한다고 가정합시다  
이 경우 일정 시간 이후 실행 또는 종료되는 함수를 정의하게 됩니다  
저는 화살표 함수를 사용하지만  
이름이 지정된 함수 등 다른 함수를 사용해도 좋습니다  
두 번째 인수는 타이머입니다  
2초라고 합시다 밀리초로 표현해야 해서  
2초라면 2000 밀리초가 되겠죠  
이 안에 간단하게 타이머가 끝났다고 적겠습니다  
이제 이 파일을 2초 동안 실행하게 되면  
아무 일도 일어나지 않고 타이머가 끝난 것을 볼 수 있습니다  
이게 바로 비동기화 코드로 즉시 끝나지 않기 때문에  
1 밀리초를 입력했더라도 마찬가지로 비동기화 코드에 해당합니다  
아무리 빠르다고 해도 즉시 발생하는 것은 아닙니다  
코드 구간에서 예를 들면 console.log  
('Hello!'), 그리고 console.log('Hi!')가 있을 때  
이 스니펫은 비동기화 코드로 각자가 끝난 뒤 곧바로 실행되지만  
기술적으로는 실행되기까지 시간이 좀 소요될 텐데, 하드웨어를 제외하고는  
딜레이가 존재하지 않으므로 동기화 코드이고  
이것이 비동기화 코드로 즉시 실행되거나 끝나지 않고  
짧긴 해도 시간이 소요됐기 때문입니다 이 파일을 이렇게 실행하면  
종료되기 전에 Hello!와 Hi!가 아주 짧게나마 나타납니다  
왜냐하면 Node.js와 JavaScript는 일반적으로  
코드 실행이 종료될 때까지는 이를 멈추지 않기 때문입니다  
여기에서는 콜백 함수라고 하는 함수를 인식할 것입니다  
즉 함수는 나중에 실행될 것입니다  
추후 완료된 이후에 답신하게 됩니다  
따라서 여기에서 타이머가 종료된 뒤에 이걸 인지하게 되며  
우리는 곧바로 다음 줄로 이동해서  
모든 동기화 코드를 실행하고  
이게 종료된 뒤에 비동기화 코드가 실행됩니다  
그래서 코드에서 Timer is done!이 먼저 출력됐음에도  
Hello!와 Hi!를 먼저 보게 되는 것입니다  
JavaScript와 특히 Node에서 이 개념은 반드시 이해해 둬야 합니다  
정말 중요하기 때문에 강의 전반에 걸쳐 다시 언급하도록 하겠습니다  
이제 이걸로 작업하면서  
뚜렷하게 하기 위해 2초로 이 값을 올리면  
동기화 코드가 실행되는 것을 다시 볼 수 있고  
2초가 지난 뒤에 이 코드가 실행됩니다  
비동기화 코드로 작업할 때는 이를 다루는 기법들이 여러 가지 있습니다  
콜백 함수는 그중 가장 오래된 함수이며  
특히 Node.js에서 자주 보게 될 것입니다  
잘못된 건 전혀 아닙니다  
그러나 몇 가지 의존성 비동기 작업의 경우 문제에 직면하게 됩니다  
여기에서는 타이머를 설정하고 다른 함수 생성을 위해  
fetchData라고 하겠습니다  
여기에도 타이머를 설정하는데  
데이터를 가져오게 되는 데이터베이스 같은 걸  
설정하고 싶지 않아, 강의를 진행하면서 다루게 되니 걱정 마세요  
여기에 또 다른 타이머는 1.5초 정도로 하겠습니다  
그리고 여기 fetchData에서 저는 이 내부 타이머가 끝났을 때  
뭔가를 실행시킬 필요가 있습니다  
여기서 저는 callback이라고 지정할 인수를 입력합니다  
이 인수는 타이머가 끝난 뒤에 제가 내부 함수로 호출할 함수이기 때문입니다  
여기에서 Done!이라는 값을 입력하고  
fetchData를 사용하는 장소가 여기  
setTime 내부라고 하고 호출하겠습니다  
이렇게 fetchData를 호출합니다 여기에서 또 다른 콜백이 필요합니다  
실행하게 되면 여기에서 함수를 콜백 하기 위해  
텍스트가 전달되어 텍스트를 입력하고  
그 텍스트를 console.log 할 수 있죠  
조금 혼란스러울 수 있는데  
저는 저만의 함수를 생성하는 중으로, 콜백을 받음으로써  
이 내부 타이머가 다른 곳에서 완료되었을 때  
실행되는 함수를 정의할 수 있습니다  
그러니까 여기에서 이 함수는 콜백으로 전달되는 것입니다  
그리고 여기서 그 함수를 실행합니다  
이제 이걸 저장하고 실행하면  
2초가 지난 뒤에 Timer is done!,  
그리고 다시 1.5초 후에 Done!이 보입니다  
만약 중첩된 비동기화 호출이 여기에서처럼 몇 개 존재하는 경우  
우리는 콜백 시점에서 점점 더 깊게 들어가게 됩니다  
그렇기 때문에 프로미스(Promise)라는 기능을 Node.js에서 사용할 수 있습니다  
이미 프로미스가 사용된 제3자 패키지를 자주 사용할 것입니다  
따라서 여기에서 보여드릴 구문은 직접 작성할 일은 거의 없습니다  
내부 패키지가 진행하게 되겠죠  
그래도 알아두면 좋습니다 fetchData 함수 내부에  
프로미스를 생성한다고 해봅시다  
상수 또는 변수로 저장하고  
JavaScript 내부에서 생성자를 기반으로  
새로운 객체를 생성하는 new 키워드를 사용합니다  
만약 생성자 함수의 의미가 전혀 와닿지 않는다면  
JavaScript에 관련된 기본 개요 자료를 찾아보세요  
생성자 함수는 JavaScript의 핵심 기능이기 때문입니다  
여기에서는 JavaScript와 Node.js  
내부에 구축된 프로미스 생성자 함수를 사용합니다  
이후 resolve와 reject라는 두 가지 인수를 콜백하게 되는데  
이름은 자유롭게 붙여도 되고 어쨌든 두 함수가 들어옵니다  
첫 번째 함수는 프로미스를 성공적으로 완료하여  
성공적으로 해결합니다  
두 번째 함수는 거부하게 되는데 예를 들면 에러를 표시하는 거죠  
다음으로 비동기화 코드를 안으로 이동시킬 수 있습니다  
다시 강조하지만 이건 직접 작성할 일은 거의 없습니다  
대부분의 패키지들이 이미 알아서 진행해 주고  
완료된 프로미스를 전달하여 배후에서  
전부 다 해결해 주지만 지금은 수동으로 진행해 보는 것이죠  
콜백 내부에 함수가 있는데  
안타깝게도 setTimeout이 프로미스 API를 제공하지 않아  
여기에도 콜백을 사용해야 하지만  
이제 더 이상 우리가 얻게 되는 콜백 함수를 사용할 수 없고  
더 이상 여기에서는 인수를 얻거나 데이터를 가져올 수 없습니다  
대신 resolve('Done!')을 입력하여 성공적으로 결괏값을  
반환합니다 이제 fetchData에서  
프로미스를 정의한 뒤에는 반환하기만 하면 됩니다  
이건 동기화 코드라는 걸 기억해 주세요  
이제 이건 프로미스 내부의 코드가 실행되기 전에  
프로미스가 생성된 직후 반환될 텐데,  
이 함수를 호출하고 이 타이머의 Done!이 완료되고 얼마 후  
일어날 일입니다  
이제 프로미스를 여기로 반환하고 fetchData를 호출하는 자리에  
더 이상 콜백을 전달하지는 않지만 프로미스 상에서  
호출할 수 있는 then을 사용하고 프로미스를 반환할 수 있습니다  
이건 단순히 콜백 함수를 여기에 정의해서  
프로미스가 해결된 뒤에 실행되도록 합니다  
그런 프로미스가 여러 개 있을 때 장점은 뭐가 있을까요?  
여기에 fetchData를 다시 호출했다면  
이런 식으로 then을 사용할 필요가 없습니다  
이 경우 다시 콜백이 중첩되겠죠  
대신 프로미스 내부에 블록이 프로미스의 일부인 경우  
간단히 새로운 프로미스를 반환하고  
다음 then 블록을 이전 블록 다음에 추가할 수 있습니다  
이렇게 하면 then 블록이 연쇄적으로 구성되어  
첫 번째 프로미스 다음에는 이 블록이 호출되고  
then 블록 내부에서 다른 프로미스를 반환하게 됩니다  
프로미스를 전달하지 않는다고 해도 then 블록은 이걸 반환하는 대신  
즉시 해결되는 프로미스로 전환하게 됩니다  
그리고 여기 이 프로미스에 관련된 다른 then 블록을 추가하면  
무한히 중첩된 콜백을 두는 것보다 훨씬 읽기 편합니다  
이걸 실행해 보면 Hello!, Hi!, Timer is done!이 보입니다  
Done!은 두 번 나타나는데  
fetchData를 두 번 호출하기 때문입니다  
처음 접하게 되면 정리하기에 좀 어려울 수 있습니다  
이 강의를 진행하면서 계속 다시 사용하면  
좀 더 명확해질 것입니다  
재차 말씀드리지만 이 코드는 직접 작성할 일이 거의 없지만  
우리의 비동기화 코드를 더 잘 관리할 수 있는 핵심 개념입니다  
이를 관리하는 다른 방법이 존재하는데  
현대 JavaScript에서는 async, await와 특수  
키워드를 사용할 수 있으며 강의 후반부에서  
따로 설명드리겠습니다  
이 구문보다 더 복잡할 수 있어 여기에서 소개해 드리고 싶진 않습니다  
한 번에 너무 많은 새 기능을 소개해 드리고  
싶지는 않으므로 이것 하나만 하겠습니다  
하지만 비동기 코드는 이해해 두셔야 합니다  
이 시점에 완전히 이해하고 계시지 않아도 괜찮습니다  
강의 내내 자주 등장할 것입니다  
왜냐하면 Node.js에는 여러 비동기화 이벤트가 있으며  
있으며 저도 여러 번 설명할 것이기 때문입니다  
프로미스도 다시 설명하니  
현재로서는 최소한 한 번 보고  
작동 방식과 활용 방법을 이해할 기회를 드리고 싶습니다  
]  

# 템플릿 리터럴 
[
템플릿 리터럴(Template literals)이라는 기능을 종종 사용하게 될 거예요.  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals  
문자열을 작성하는 다른 방법입니다.  
큰따옴표나 작은따옴표를 사용해  
'A String'  
혹은  
"Another string"  
와 같은 방식으로 표현하거나,  
백틱(`)을 사용해  
`Another way of writing strings`  
와 같은 방식으로 표현합니다.  
왜 문자열을 이런 방식으로 표현할까요?  
이 구문을 사용하면, 문자열에 다양하게 데이터를 추가할 수 있어요.  
const name = "Max";  
const age = 29;  
console.log(`My name is ${name} and I am ${age} years old.`);  
처럼요.  
기존의 문자열 결합 방식보다 짧고 읽기 쉽습니다.  
const name = "Max";  
const age = 29;  
console.log("My name is " + name + " and I am " + age + " years old.");  
와 비교해서 말이죠.  
]

# 유용한 자료 및 링크
[MDN JavaScript 튜토리얼](https://developer.mozilla.org/en-US/docs/Learn/JavaScript)
[Academind JS 자료](https://academind.com/learn/javascript)

# Node 서버 생성
[nodejs의 코어모듈과 라이브러리](https://chat.openai.com/c/0b4047bc-4a2b-4fa6-a815-78a5d4d99466)

# 요청과 응답 헤더
[요청과 응답 헤더](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)

# 라우터 요청

# 이벤트 기반 코드 실행의 이해

# 블로킹 및 논블로킹 코드
[
그럼 여기 이 writeFilesSync 라인은 뭐가 문제일까요?  
Sync 키워드가 문제 있습니다  
앞서 말씀드렸듯이 writeFile 메서드도 존재하지만  
writeFileSync를 사용하였습니다 여기에서 sync는  
동기화를 의미합니다 그리고 이것은 이 파일이 생성되기 전까지  
코드 실행을 막는 특별한 메서드입니다  
이 파일들을 작업하는 데에는 두 가지 모드가 존재하는데  
파일이 완료될 때까지 코드의 다음 라인이 실행되지 않도록 하는  
동기화 모드가 있습니다  
우리가 입력하는 이 짧은 텍스트의 경우 알아차리지도 못할 정도로 아주 빠르지만  
수백 메가바이트 이상의 큰 파일에서  
이 방법을 적용함으로써  
읽거나 복사하는 등의 상황에서 코드 실행을 막는 경우  
다음 줄과 다른 모든 코드가  
파일 운영이 완료될 때까지 실행을 멈출 것이며  
다른 유저들이 보내어 새로 유입되는 요청들도  
파일 운영이 끝나기 전까지는 취급되지 않을 것입니다  
그런 건 원하지 않을 테니 여기선 해당 구문을 사용하지 않겠습니다  
매우 짧은 파일 운영만을 진행하는 경우  
사용할 수는 있겠지만 그렇다 하더라도 이 파일 쓰기 방법을  
사용하는 편이 더 나은데, 경로와 데이터를 받아들일 뿐만 아니라  
세 번째 인수인 콜백까지도  
포함하기 때문이며  
따라서 완료된 뒤에 실행되어야 하는 함수에 해당합니다  
그래서 서버 생성 때와 마찬가지로 Node.js는 암묵적으로  
이벤트 리스너를 등록시킵니다  
여기에서 다른 함수를 넘기고 이 콜백은 오류 객체를 전달받는데  
오류가 발생하지 않았다면 공란으로 남아있을 테지만  
권한 누락을 비롯한 어떤 오류가 발생한 경우라면  
여기로 가져오게 되며  
다른 종류의 응답, 즉 사용자에게  
오류가 발생했음을 나타내는 오류 응답 등을 반환하고  
그렇지 않다면 정상 응답을 반환하는 방식으로 처리할 수 있습니다  
지금은 오류에 대해 다루지 않을 예정이고 딱히 뭔가 잘못될 부분도 없습니다  
물론 강의를 좀 더 진행한 뒤에는 오류에 대해서도 살펴보도록 하겠습니다  
이 응답은 파일 작업이 완료된 경우에만 전송되어야 하기 때문에  
일반 응답 코드를 거기로 옮기겠습니다  
이게 요청에 따라 결국 수행하려는 작업이기 때문입니다  
이제 이벤트 리스너와 함께 요청을 파싱 하는 것이 끝난 뒤  
실행하게 될 메서드 내지는 함수를 확보하게 되었으며  
추후 언젠가 실행될 해당 함수 내부에도  
또 다른 이벤트 리스너가 있고 여기 이렇게 중첩된 함수는  
우리가 파일을 기록하는 과정이 끝난 뒤에 실행될 것이며  
이러한 과정은 Node.js에서 상당히 표준적입니다  
이벤트 드리븐 아키텍처에서는  
Node.js에게 작업을 진행하도록 지시하며  
이후 Node.js가 해당 프로세스를  
멀티 스레딩을 사용하는 운영체제에 전달하며  
이벤트 콜백을 파악하기 위해  
이벤트 루프를 계속하면서  
코드 실행을 막지 않도록 그런 작은 조치들을 발송하고  
운영체제에서 작업이 끝난 뒤에는  
항상 복귀하는 식의 구조를 지닙니다  
이게 바로 Node.js의 구조이며 그토록 뛰어난 성능을 발휘하는 이유로  
여러분의 코드를 절대 막지 않고 서버를 막는 일도 없으며  
단지 계속해서 운영체제에게 작업들을 할당하고  
완료된 뒤에는 돌아와서 콜백에서  
응답을 전달하는 등의 작업을 진행하는데 이는 헤더 몇 개만  
진행하면 끝나는 작업이므로 전체 운영을 막는 일이 없습니다  
충분히 이해하셨길 바라고  
이제 서버를 종료 후 다시 시작하겠습니다  
노드 앱을 다시 실행한 뒤 /뒤에는 다 지우고요  
여기 Hello again을 입력해서 전송해 보겠습니다  
message.text를 다시 보면 again이 추가 문자로 연결되어 있지만  
지금은 여기에 대해 걱정할 필요가 없습니다  
이렇게 writeFile도 작동하는 걸 확인해 봤는데  
Node.js의 비동기적 특성으로 인해 이런 방법으로 사용해야 합니다  
이 부분은 Node.js의 핵심 개념이고  
분명히 이해해야 하는 부분입니다  
핵심적인 기본 사항들을 다루는 걸로 이 모듈을 마무리하고  
이제 좀 더 쉬운 방법으로 넘어가서  
이런 핵심적인 세부 코드를 우리가 직접 쓰는 일 없이  
더 간편하게 작성해 보도록 합시다  
하지만 이 부분의 작동 원리를 이해하는 것은 정말로 중요합니다      
]

# Node 모듈 시스템 사용
[  
이제 이번 모듈을 마무리할 시간입니다  
마치기 전에  
코드를 조금 고쳐볼까요  
한 파일만 해도 이렇게 많은 코드가 있는데  
보통은 여러 파일을 작업하게 될 거예요  
url 확인 등의 작업을 하는 라우팅 로직을 포함한  
새 파일을 만들어볼까요  
routes.js라는 새 파일을 생성할게요  
이름은 마음대로 지으셔도 됩니다  
그러면 이런 아이콘이 뜨는데  
보통 JavaScript 파일입니다  
routes.js 파일에  
if문과 기본 응답 코드를 넣기 위해  
app.js 파일에서 잘라내서  
깔끔한 파일로 남긴 다음 routes.js에 붙여 넣습니다  
그중에 if문은  
아마 다른 방법을 사용해야 할 거예요  
하지만 코드는 옮겨졌으니  
이제 app.js에 필요하지 않은 파일 시스템은 제거합니다  
http는 아직 필요하지만  
url과 method는 필요하지 않으니  
지운 다음 routes.js로 넘어가  
가장 위에 fs를 추가한 상태에서  
시작합시다  
이제 routes.js 파일에 뭘 해야 할까요  
app.js를 routes.js로 연결할 수 있어야겠죠  
들어오는 요청을 routes.js 파일로  
보낼 수 있어야 하니까요  
새로운 함수로  
requestHandler 함수를 생성해  
req, res를 인수로 가지면  
http.createServer 함수를 대체하게 됩니다  
혹은 ES6 함수를  
상수 requestHandler에 저장할 수 있죠  
처음 보는 구문이라면 낯설게 느낄 수 있는데  
근본적으로  
상수에 저장하는 익명의 화살표 함수이며  
함수의 이름은 requestHandler입니다  
이제 req, res를 넣은 후  
아래에 있는 모든 코드를 함수로 옮겨야 합니다  
코드가 요청 및 응답 객체를 사용하기 때문에  
인수가 같은 이름을 사용하도록 만들면  
로컬 변수로 사용 가능하게 되는 거죠  
url과 method도 사용하기 때문에  
req.url과 req.method의 데이터를  
다시 상수로 추가해야 합니다  
이제 핸들러를 내보내기만 하면 되는데요  
불러올 때는 require 구문을 사용했다면  
내보낼 때는 어떻게 해야 할까요  
내보내기를 하는 두 가지 방법이 있습니다  
첫 번째 방법은 가장 아래에  
module.exports를 추가하는 겁니다  
Node.js에 의해 전역으로 노출된  
키워드 혹은 객체로 내보내기 속성이 있어서  
requestHandler 등의 값을 지정하면  
다음과 같은 함수를 가진 requestHandler 상수가  
module.exports에 저장됩니다  
노출된 전역 객체이기 때문에 Node.js가 처리할 수 있죠  
이제 require로 routes.js 파일을 불러오면  
Nodes.js가 module.exports를 찾아  
등록된 것이 있는지 보는데요  
우리는 module.exports에  
requestHandler를 등록했죠  
여러 키-값 쌍을 가진 JavaScript 객체를 추가해도 되고  
원하는 대로 추가할 수 있는데  
저는 이 함수를 등록했어요  
이제 app.js로 돌아가  
원하는 대로 상수 이름 routes를 입력하고  
require을 통해 불러옵니다  
글로벌 모듈이 아니기 때문에 routes만 입력하지 않고  
./로 로컬 경로를 추가하는데  
대신 끝에 .js는 생략해도  
Node.js가 자동으로 붙일 거예요  
물론 직접 .js를 붙여도 되지만 저는 ./routes만 입력할게요  
또 상단의 코어 모듈과 분리해서  
사용자 지정 파일임을 분명히 하겠습니다  
그럼 Node.js가 app.js와 같은 폴더에서  
routes.js 파일을 찾아서  
module.exports에 무엇이 등록되어 있는지 볼 겁니다  
이때 requestHandler 메서드를 내보내면  
routes를 통해 사용할 수 있게 됩니다  
파일에서 내보내는 모든 것들을  
routes 상수로 지정했기 때문이죠  
routes 상수가 이 함수를 갖고 있으므로  
여기서 핸들러로 사용할 수 있는 거예요  
routes를 입력한 후 실행하지 말고  
괄호도 넣지 않은 채 이름만 입력해서  
들어오는 요청에 대해 routes에 저장된 함수를  
실행하라고 알려줍니다  
저장한 후에 서버를 재시작하고  
이 페이지를 재로딩해도 문제없고  
Test를 발송해 봐도 문제없네요  
message.text에 Test가 저장됐습니다  
이렇게 코드를 두 파일로 나눴습니다  
깔끔한 app.js 파일은 서버를 가동하는  
중요한 역할을 하고  
불러오기와 내보내기를 통해 routes.js 파일로 연결해요  
requestHandler의 함수를 내보냈죠  
바로 이런 원리입니다  
Node.js 모듈 시스템에서 한 가지 중요한 점은  
파일 내용의 캐시가 저장되고  
외부에서 수정할 수 없다는 겁니다  
만약 routes를 객체로 정의하고  
새로운 속성을 추가하려고 하면  
원본 파일을 조작할 수 없어요  
즉 잠금 되어 외부가 접근할 수 없기 때문에  
외부에서 읽을 수 있는 내용만 내보내기 할 수 있는 겁니다  
내보내는 함수가  
내부적으로 변경 사항을 만들 수는 있지만  
지금 당장 너무 깊게 들어가지 않고  
강의를 진행하면서 차차 배워보겠습니다  
지금 상태에서 module.exports 대신에  
사용할 수 있는 구문이 하나 더 있어요  
가끔 여러 내용을 한꺼번에 내보내기 하는 경우  
객체로 handler 키워드를 입력하면  
requestHandler 함수와 같고  
someText를 입력하고  
여기서는 Some hard coded text라고  
입력하면 두 가지를 내보낼 때  
둘을 그룹화하거나 분리하면서도  
하나의 내보내기만 관리할 수 있게 됩니다  
그러면 app.js에서 routes는  
함수가 아닌 객체가 되는 거죠  
그럼 여기서 handler 속성에 접근해야 하는데  
이 속성은 사용하고자 하는 함수를 참조하고 있죠  
아니면 console.log로  
routes.someText를 출력할 수도 있습니다  
이렇게 하면 하나의 파일에서 여러 내보내기를 할 수 있고  
console.log로 인해 출력된 Some hard coded text가 보이는데  
기능은 예전과 같습니다  
이 코드 외에도 여러 가지를 내보내는  
다른 방법은  
module.exports.handler = requestHandler나  
module.exports.someText = 'Some hard coded text'입니다  
달라 보일 수도 있지만  
아직 하나의 exports  
즉 모든 내보내기를 묶는 module.exports가 있고  
handler나 someText 속성을 지정했기 때문에  
바로 이 코드와 똑같습니다  
이제 저장한 후에 서버를 재시작하면  
Some hard coded text가 출력되고  
무작위로 입력해 제출하면 문제없이 작동되네요  
마지막으로 이 구문에는 단축키가 있는데요  
module를 생략하고 exports만 입력해도 됩니다  
JavaScript 자체가 아니라  
Node.js에 의해 특별히 지정된 단축키예요  
이제 여러 개의 내보내기를 하나의 내보내기로 합쳤으니  
다시 실행해 보면  
역시 Terminal에는 Some hard coded text가 보이고  
Some last value를 보내면  
문제없이 작동되고  
message.text에 남습니다  
이렇게 여러 개의 파일을 연결해 봤습니다  
module.exports = requestHandler라는  
하나의 함수를 내보내는 것이  
첫 번째 방법이었고요  
앞에 슬래시 두 개를 붙여 코멘트로 만들어 둘게요  
혹은 객체에 대한 module.exports로  
여러 개를 합치거나  
module.exports.handler = requestHandler나  
module.exports.someText = 'Some text'를 사용하는데  
아래에 있는 단축키와 같고  
Node.js가 지원하는 단축키였죠  
여기까지 불러오기 및 내보내기와  
모듈 시스템의 원리에 대해 배웠습니다  
강의를 진행하면서 많은 파일을 다룰 예정이기 때문에  
꼭 이해하고 넘어가는 것이 중요합니다  
그럼 이제 이번 모듈을 마무리하도록 합시다      
]  

# 모듈 마무리
[
오늘 강의에서는 이번 모듈을 요약해 볼게요  
가장 먼저 웹의 원리를 알아봤습니다  
전반적으로 다음과 같습니다  
클라이언트인 브라우저가 서버에 요청을 보내면  
서버가 데이터베이스에 접촉해 파일을 다룬 후  
HTML 혹은 다른 종류의 응답을  
클라이언트에 발송하고  
브라우저가 이 응답을 보여주게 됩니다  
이번 모듈에서 전체적인 흐름을 본 적 있죠  
Node.js 프로그램이 바로 이 서버에서 작동합니다  
프로그램의 주기에 관련된  
중요한 개념으로는 이벤트 루프가 있었어요  
Node.js 코드는 논블로킹 방식으로 실행됩니다  
즉 수많은 콜백과 이벤트를 등록해두면  
특정 작업이 끝난 후에  
Node.js가 해당 코드를 작동시킨다는 뜻입니다  
따라서 JavaScript 스레드는 항상 새 이벤트나  
새로 들어오는 요청 등을 다룰 수 있게 됩니다  
더 이상 작업이 없을 때는 프로그램이 종료되는데  
서버에서는 절대 그럴 일이 없어요  
createServe가 절대 끝나지 않는 이벤트에 대한  
이벤트 리스너를 등록하기 때문이죠  
새로운 이벤트가 발생해도 즉 새로운 요청이 들어와도  
이벤트 리스너의 등록을 취소하지 않아요  
대신 서버는 계속해서 들어오는 요청을 들어야 하죠  
따라서 이런 주기를 이해하는 것이 중요합니다  
루프는 계속해서 새로운 이벤트를 기다리다가  
이벤트가 발생하면  
운영 체제가 어떠한 조치를 취할 수 있도록 한 다음  
스레드를 비웁니다  
여기에는 콜백을 통해 본 것처럼 많은 비동기식 코드가 필요합니다  
JavaScript 코드는 논블로킹 방식이어야 해서  
콜백 등 이벤트 기반 방식을 이용하죠  
코드가 바로 실행돼서 메인 스레드를 막지 않도록  
등록해서 나중에 실행하게 합니다  
어느 경우에도 메인 스레드가 막히면 안될 뿐더러  
Node.js는 그런 문제를 피하도록 설계되었어요  
Node.js 방식대로 요청과 응답을 다루는 법도 배웠죠  
청크로 도착하는 요청 데이터를 분석하는 데 사용하는  
스트림과 버퍼라는 개념도 배웠습니다  
또 이중 응답을 보내지 않도록 유의해야 합니다  
즉 한 res가 끝난 다음에  
다른 응답을 보내지 않아야 하는데  
비동기식 특성에 따라 코드가  
바로 실행되지 않을 수도 있다는 사실을  
잊어버리면 실수하기 쉬워요  
따라서 코드를 어디에 작성하냐에 따라  
예를 들어 이벤트 리스너의 경우 바로 실행되지 않는다는 점을  
기억하는 것이 중요합니다  
또 Node.js는 내장된 기능을 사용하는 프로그램으로  
글로벌 변수, 객체 혹은 함수도 사용할 수 있지만  
주로 코어 모듈을 사용합니다  
코어 모듈에는 http, fs path 등의 모듈이 있고  
더 많은 코어 모듈을 알고 싶다면  
공식 Node.js 홈페이지에서 정보를 찾을 수 있어요  
강의를 진행하면서 코어 모듈을 많이 사용할 건데요  
코어 모듈에는 서버에 원하는 어떤 작업이던  
할 수 있도록 하는 몇 가지 기능이 있어요  
예를 들어 http 모듈을 통해  
새로운 서버를 생성할 수 있죠  
코어 모듈은 require 구문으로 불러오고  
불러온 파일 내에서만 사용할 수 있습니다  
만약 다른 파일에서 사용하고 싶다면  
다른 파일에도 따로 불러와야 하죠  
이어서 배운 노드 모듈 시스템 역시  
require 키워드를 이용해서  
/나 ./ 경로로 시작하는 경우  
다른 파일에서 기능을 불러오거나  
코어 모듈 혹은 제3자 모듈에서 불러올 수 있어요  
아직 제3자 모듈을 사용한 적이 없는데  
조만간 사용해 볼 예정입니다  
이번 모듈에서 본 것처럼 다른 파일 혹은 모듈에서  
내보낸 것을 불러와서  
새로운 변수나 상수로 저장하는데요  
export가 중요한 키워드로  
module.exports를 사용해서 내보내거나  
여러 개를 내보내기 할 때는  
지난 강의에서 보여드린 단축키를 사용할 수 있죠  
이렇게 이번 모듈에서 배운 내용을 정리해 봤습니다  
주로 이론적이거나 근본적인 내용이었기 때문에  
쉽거나 흥미로워 보이지 않았을 수도 있는데  
지금부터는 좀 더 흥미로워질 거예요  
그전에 Node.js의 원리를 이해해두는 것이 좋습니다  
많은 강의가 Express.js로 바로 시작하며  
우리도 곧 Express.js를 바로 사용하게 됩니다  
실제로 무슨 일이 벌어지는지 배울 기회가 없어질 텐데  
좋은 노드 개발자가 되기 위해서는  
이런 중요한 내용을 알아야 하잖아요  
여기까지 마치고 다음으로 넘어가 봅시다      
]

# 유용한 자료 및 링크
[
유용한 자료 및 링크  
첨부된 파일은 이번 섹션의 소스 코드입니다.  
아래의 유용한 자료를 참고하세요.  
공식 Node.js 자료: https://nodejs.org/en/docs/guides/  
모든 코어 모듈에 대한 Node.js 참고자료: https://nodejs.org/dist/latest/docs/api/  
Node.js 이벤트 루프 추가자료: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/  
블로킹 및 논블로킹 코드:https://nodejs.org/en/docs/guides/dont-block-the-event-loop/  
]

# 섹션 4: 개선된 개발 워크플로우 및 디버깅 > 모듈소개
[  
지금까지 Node.js를 어느 정도 자세히 들여다보고  
여러 작업을 해봤으니  
한 발짝 뒤로 물러나  
좀 더 개발을 쉽게 하면서  
속도를 높일 수 있는 방법을 알아봅시다  
가장 중요하게 Node.js 앱을 디버그 하거나  
Node.js 앱에 일어나고 있는 일을  
알 수 있도록 하는 몇 가지 툴을 배워볼 거예요  
이번 모듈에서는  
Node.js 앱을 효율적으로 작성할 수 있는  
비법과 요령을 얻도록 도와드릴게요  
]  

# 섹션 4: 개선된 개발 워크플로우 및 디버깅 > 42. NPM 스크립트의 이해
[
이 모듈에서는 우리가 마지막 핵심 섹션에서 작업했던  
애플리케이션 내지는 프로젝트로 돌아왔습니다  
이 영상에 현재 상태가 적용된 파일을 첨부해 뒀으니  
저와 동일한 지점에서 시작하실 수 있습니다  
우리가 지난 강의들에서 작성해 온 코드입니다  
이번 강의 전반에 걸쳐  
우리가 계속해서 해 온 일은  
node app.js를 실행해야 파일과 앱 내지는 노드 애플리케이션을  
시작할 수 있었던 것입니다  
그리 부담되는 일은 아니라서 괜찮긴 하지만  
Node.js 프로젝트에 몇 가지 스크립트를 정의하여  
이런 태스크에 있어 우리가 도움을 받는 것도 가능합니다  
다른 태스크에서도 사용할 수 있으나 특히 지금 이 시점에 유용할 것이고  
이를 위해 우리는 아직 사용하지 않은 기능을 사용해야 합니다  
NPM을 사용해야 하는데, 이는 노드 패키지 매니저를 뜻하며  
Node.js 내부에 함께 설치되어 있습니다  
별도의 작업 없이도  
이미 설치되어 있어요  
이제 NPM을 사용해서 조만간 우리의 패키지에 몇몇 추가  
제3자 패키지, 그러니까 노드 코어에  
포함되지 않은 패키지 즉 노드 코어 모듈의 일부가 아닌  
패키지들을 설치할 것입니다 하지만 NPM을 사용하면  
노드 프로젝트라고 부르는 작업의 초기 내용을 설정할 수 있고  
정확히 말하자면  
여기 이미 노드 프로젝트가 있지만  
프로젝트에서 이 프로젝트로 이동하는 Terminal에서  
NPM을 실행할 수 있습니다  
코드를 삭제한다던가 그런 일은 없으니까 걱정하지 마세요  
Enter 키를 누르면 몇 가지 질문들이 등장합니다  
먼저 패키지의 이름을 물어볼 텐데  
지금은 간단하게 프로젝트 이름으로 바꿔주면 됩니다  
원하는 이름을 자유롭게 사용하셔도 됩니다 여기에서 괄호 안의 부분은  
항상 제안 사항이며 자신의 이름을 선택하지 않으면  
기본값이 선택됩니다  
따라서 여기서 Enter를 누르면 이 기본값이 됩니다  
이런 식으로 질문들을 전부 진행하면 되며,  
설명 항목의 경우 비워두면  
기본값으로 입력되는 텍스트가 없지만  
이 강의의 제목인 Complete Node.js Guide  
등을 입력해 주고 App.js의  
진입점을 정의해 줍니다 (역자주: 당장 이 진입점은 아무것도 하지 않습니다.)  
태스크 명령어는 완전히 비워두고 키워드는 원할 경우 입력하셔도 됩니다  
Author 필드에는 이름을 입력해도 무방하지만  
굳이 필요한 건 아니고 라이선스도 선택할 수 있지만  
이 프로젝트를 공개적으로 공유할 계획이 없다면  
이 항목도 큰 의미는 없습니다  
그럼 이제 package.json 파일이 생기게 되며 방금 설정한 모든  
설정 내지는 구성을 확인하실 수 있고 여기에서도 편집할 수 있습니다  
설명에서 오타가 난 경우 여기에서 수정하시면 됩니다  
기본적으로 JavaScript 객체와 매우 유사해 보이는 특수한 종류의  
데이터 형식인 JSON 형식을 사용하며​​이를 기반으로 합니다  
하지만 이해하고 넘어가야 할 중요한 점 하나는  
키들은 항상 쌍따옴표 안에 입력하고  
숫자나 배열 또는 참이나 거짓을 제외한 다른 값들도  
쌍따옴표 안에 입력해야 하지만  
지금 다루기엔 너무 멀리 나간 내용이니  
우선은 무시하고 현재 파일 프로젝트의  
구성 파일이라는 것만 이해하도록 합시다  
이 구성 파일은 어떤 역할을 하는 걸까요?  
여기 콘솔을 일단 정리하고  
이 구성 파일을 살펴보면 scripts 구획이 있는데  
지금은 아무 역할도 하지 않는 script가 기본값으로 하나 있고  
여기에 다른 스크립트들을 추가할 수 있어 실행하는 방법을 알려드리겠습니다  
추가를 위해 이 시험 스크립트 다음에 쉼표를 입력하고  
쌍따옴표 사이에 새로운 스크립트 이름을  
추가하기 위해 이름을 start로 하겠습니다  
start는 곧바로 알게 되겠지만 특수한 스크립트 이름입니다  
정확하게 입력하고 쌍따옴표 사이에  
실행해야 할 명령어를 입력합시다  
이 명령어는 여기 아래쪽에도 입력할 수 있으며  
여기에는 항상  
node app.js를 입력하고 이제 여기 두 쌍따옴표 사이에  
"node app.js"를 입력합니다  
그 뒤 파일을 저장하고  
npm start를 실행합니다 start는 따로 할당된 이름으로  
항상 start 스크립트를 탐색할 것입니다  
그러고 나서 여길 보시면 node app.js가 실행되어 있습니다  
즉 예전과 동일한 일을 했지만 이젠 node app.js 대신  
항상 이 명령어만 실행하면 됩니다  
글자 수를 크게 줄이진 않았지만 최소한 어느 정도 줄여주긴 했고  
좋은 습관으로 이 프로젝트를 공유할 일이 있다면  
사람들이 간단히 npm start만 실행하면 되고  
어느 JavaScript 파일이 진입 파일인지를  
일일이 파악하지 않아도 되기 때문입니다  
이제 늘 그랬듯이 Ctrl+C로 종료하시면 되고  
말씀드렸다시피 이건 특별한 스크립트 이름입니다  
특별한 이름을 사용하지 않고 다른 스크립트도 추가하실 수 있고  
이름은 자유롭게 선택하실 수 있습니다  
단지 항상 이름은 쌍따옴표 안에 입력하도록 하고  
여백이나 공백은 포함하지 않도록 하십시오  
예를 들면 start-server가 있습니다  
이것도 node app.js를 실행할 수 있으며  
이 스크립트와 동일한 기능을 가지므로 당연히 중복되겠지만  
보여주고 싶은 것이 있습니다  
npm start-server를 실행하면 오류가 발생합니다  
알려지지 않은 명령어라는 오류가 등장하는데  
실제로 맞는 말입니다 왜냐하면 여기에 스크립트 이름만  
입력했을 때는 작동하지 않기 때문입니다 아까 말한 start는 특수한 경우였죠  
개별 설정된 이름이 있는 일반 스크립트의 경우  
npm run 입력 후에 스크립트 이름을 입력해야 해서  
npm run start-server 를 입력해 줘야 서버가 시작됩니다  
아까 말했듯이 이건 불필요하며 npm start가 훨씬 짧지만  
본인만의 스크립트를 추가하는 방법을 이해하시도록 말씀드린 내용입니다  
Angular, React, Vue 또는 기타 최신 프론트엔드  
개발 워크플로우로 작업해 보셨다면  
자주 이런 스크립트를 사용해서  
프로젝트의 빌드 워크플로우를 시작하는 경험을 해 보셨을 것이고  
실행하고 싶은 다양한 태스크에 이를 적용할 수 있습니다  
하지만 지금은 거기까진 다루지 않겠습니다  
Angular이나 React를 다뤄본 적이 없어도 괜찮습니다  
이 강의에서 나중에  
노드의 빌드 도구로서의 기능성에 대해 좀 더 알아볼 때 이해하시게 될 겁니다  
일단 지금은 npm start 스크립트를 사용하여 애플리케이션을 쉽게 시작합시다  
]

# 섹션 4: 개선된 개발 워크플로우 및 디버깅 > 43. 제3자 패키지 설치하기
[
지난 강의에서 애플리케이션을 시작하기 위해 스크립트를 추가했고  
이러한 스크립트의 기능성이 있다는 걸 숙지하면 좋습니다  
package.json 파일이 있으므로  
이 관리 노드 프로젝트에서  
또 다른 매우 중요한 작업을 진행할 수 있습니다  
바로 제3자 패키지를 설치하는 것으로 일반적인 노드 프로젝트가  
이런 구조를 띠기 때문입니다 로컬 프로젝트에는 당연히 코드가 있고  
FS 패키지나 이미 사용 중인 HTTP 패키지를 비롯한  
여러 코어 노드 패키지를 사용하게 됩니다  
이걸로는 충분하지 않은 경우가 제법 있으며  
다음 핵심 섹션에서 실제로 큰 제3자 패키지를 설치할 것입니다  
일반적으로 그런 제3자 패키지에 대한 종속성이 있기 때문입니다  
따라서 직접 작성하지 않은 어떤 기능이나 코드를  
사용하고 싶지만 Node.js에도 포함되지 않은 경우  
패키지들을 사용함으로써 들어오는 요청을 파싱하고  
사용자 입력 유효성 검사 등의 작업에 도움을 받을 수 있습니다  
다음 강의 내지는 다음 모듈에서는 Express를 사용하고  
이 강의 전반에서 사용할 또 다른 패키지로는  
body-parser가 있으며 완전히 새로 구축하는 일 없이  
프로젝트에 추가할 수 있는 다양한 기능들을 제공하는  
패키지들이 수천 종류 이상 있습니다  
이 패키지들은 NPM 저장소는 모든 패키지들이 저장된  
클라우드 패키지 저장소를 통해 사용할 수 있으며  
이 패키지들은 노드와 함께 제공되는 도구인 NPM을 사용하여  
간편하게 설치 및 관리할 수 있습니다  
이제 우리는 먼저 개발 워크플로우의  
속도를 올리기 위해 작은 유틸리티 패키지를 설치해 보겠습니다  
왜냐하면 지금은 코드를 변경할 때마다  
Ctrl+C를 눌러 개발 서버를 종료하고 재시작해야 하죠  
따라서 이제 서버를 시작할 때 사용하는 새로운 명령어인 npm start로  
서버를 실행하고 있는 중에 여기에서 뭔가 변경한다면,  
예를 들어 /head 부분을 고쳤다면 이런 수정을 할 때마다  
변경사항이 적용되도록 저장하고 Ctrl+C를 눌러  
서버를 종료한 다음 재시작해야 합니다  
이건 좀 번거로울 수가 있는데 왜냐하면 그냥 입력한 다음 저장을 눌러서  
자동으로 재시작할 수만 있다면  
개발 워크플로우가 잘 이어질 것입니다  
이걸 가능하게 하려면 해당 기능이 있는 제3자 패키지를 설치해야 합니다  
그럼 이 제3자 패키지는 어떻게 추가할까요?  
NPM의 도움을 받아 install 명령어를 사용하게 되고  
run으로 스크립트를 실행했듯이 install은 제3자 패키지를 설치합니다  
어떻게 설치할까요?  
먼저 패키지 이름을 알아야 합니다  
이때 패키지 이름을 잘 모르시겠다면  
이런 강의를 듣고 경험을 쌓거나  
해결하고 싶은 문제들을 검색하는 도중에  
특정 패키지들이 언급된 게시물을 발견하는 과정 등을 통해 습득하게 됩니다  
이 자동 재시작 메커니즘의 경우  
Nodemon이라는 패키지가 있습니다  
참고로 이름을 알고 있는 패키지의 경우  
npm 입력 후 패키지 이름을 넣고 검색하게 되면  
npmjs.com에서 찾으실 수 있습니다  
여기는 패키지 웹 사이트로  
패키지의 설명, 설치 안내, 사용 안내, 구성 방법 등을  
찾아보실 수 있는데 대부분의 패키지들은 쉬운 사용 방법을 제공하며 항상  
구성 변경이 가능하게 합니다  
패키지의 인기도라던가  
사용하는 버전, 외부 홈페이지의 유무,  
오픈 소스인 경우 소스 코드가 있는 곳 등을 살펴보실 수 있습니다  
상당히 도움이 되는 내용이 많이 수록되어 있습니다  
버전은 총 몇 개가 있는지도 알 수 있고  
설치할 때 기본값은 항상 최신 버전을 설치하게 됩니다  
NPM을 더 알아보기 앞서  
우선 설치 과정으로 돌아가 봅시다  
이걸 설치하려는 중이고 이 명령어로 설치할 수 있지만  
아직 Enter를 누르진 마세요  
설치 방법 정의가 가능하여  
개발 중에 도움을 주는 개발 패키지와  
서버에서 실행 중인 앱에 도움이 되는  
프로덕션 의존성으로 정의가 가능합니다  
Nodemon의 경우 개발 과정에서만 사용하기 때문에 개발 의존성이 됩니다  
우리가 실제 서버에 앱을 설치하게 되면 거기에서는 필요가 없죠  
인터넷 어딘가에서 실행 중인 실제 서버는 재시작해서는 안 되며  
그럴 필요도 없고 그 서버의 코드는 동적으로 변경하지 않으니까요  
NPM에 어떤 종류의 의존성에 해당하는지를 알려줄 수도 있지만  
이건 큰 차이를 보이지는 않는 항목이며  
이 설정은 건너뛰기 할 수도 있지만 어떤 패키지가 어떤 용도에  
사용되는가를 이해하는 데는 도움이 됩니다  
이제 --save-dev를 추가합니다  
--save만 입력하면 패키지가 프로덕션 의존성으로 설치되며  
실제로 코드 안에서 사용하고 작업하는 패키지입니다  
-dev를 추가하게 되면  
단순히 개발 도중 사용하는 것임을 나타냅니다  
참고로 세 번째 선택지인 -g는  
이 프로젝트에서는 설치하지 않겠지만 머신 전체에 설치함으로써  
어디에서든지 사용할 수 있도록 합니다  
먼저 --save-dev를 사용하여 이렇게 설치합시다  
이제 NPM 저장소에서 다운로드받아  
머신 전체가 아닌  
이 프로젝트에만 설치하게 됩니다  
이후 성공적으로 완료되어 진행한 내용이라던가  
프로젝트에 새로운 기능 몇 가지가 추가되었음을 알리는  
보고서가 등장합니다  
node_modules 폴더, package-lock.json 파일이 추가되었으며  
package.json 파일이 업데이트 되었습니다  
개발 의존성을 나타내는 devDependencies가  
새로 추가되었음을 볼 수 있고  
전에 말씀드렸듯이 다양한 의존성들은 서로 구별할 수 있고  
나중에 프로덕션 의존성도 살펴보겠습니다  
Nodemon이 설치되었고 어떤 버전인지도 볼 수 있습니다  
여기 이 문자의 경우  
이 패키지가 어떻게 업데이트될지를 정의하여  
재실행하려면 npm install만 입력해 주고  
별도의 패키지 이름 입력은 필요 없습니다 이 명령어는 자체적으로  
package.json에 언급된 모든 패키지를 검색해서 설치하고  
가능한 경우 자동으로 최신 버전을  
선택하게 됩니다  
NPM과 패키지에 대한 더 많은 내용은 추후 강의에서 별도의 모듈을 통해  
다룰 예정이기도 합니다  
설치하는 방식은 이제 알았고  
그럼 어디에 설치되는 걸까요?  
node_modules 폴더로  
보시다시피 방대한 폴더입니다 그 이유는  
여기 n을 찾아서 nodemon을 보면  
여길 보시면 이게 패키지의 소스 코드  
내지는 우리가 설치한 패키지의  
빌드 버전에 해당하여  
이 패키지에는 피어(peer) 의존성이 몇 개를 포함하기 때문입니다  
여기랑 여기 있죠  
그러니까 여러 의존성들이 있는데 이 의존성들도 설치되어 있기 때문에  
꽤 큰 node_modules 폴더가 되어버린 것이지만  
공간을 확보해야 한다면  
이 폴더는 언제든지 삭제할 수 있습니다  
패키지는 사용할 수 없게 되지만  
프로젝트를 다시 시작할 때 npm install를 입력하면  
이 패키지와 다른 피어 의존성들이 다시 설치되며  
node_modules 폴더가 다시 생성됩니다  
이것이 패키지가 노드 프로젝트에서 작동하는 방식입니다  
패키지를 사용 중이라면 node_modules 폴더가 필요하지만  
프로젝트를 작업 중이 아니라면 지우셔도 됩니다  
용량이 필요하면 지워도 되고 다시 프로젝트를 작업할 때  
npm install을 실행해서 설치해 주시면 됩니다  
package-lock.json 파일은 오늘 설치했던  
바로 그 버전들만을 저장하므로 만약 다른 사람들과 프로젝트를  
공유하게 된다면 최신 버전 대신  
오늘 설치한 버전을 사용할 수 있습니다  
NPM에 대한 자세한 내용은 별도의 모듈에서 다루겠습니다  
]  

# 섹션 4: 개선된 개발 워크플로우 및 디버깅 > 44. 전역 기능 vs 코어 모듈 vs 제3자 모듈
[
전역 기능 vs 코어 모듈 vs 제3자 모듈  
지난 강의에서 Node.js에서 사용 가능한 기능들의 중요한 개념과 사용법을 알려드렸습니다.  
기본적으로 다음과 같이 구분할 수 있습니다.  
전역 기능: const나 function 같은 키워드 및 process 등의 전역 객체  
코어 Node.js 모듈: 파일 시스템 모듈 ("fs"), 경로 모듈 ("path"), Http 모듈 ("http") 등  
제3자 모듈: npm install을 통해 어떤 종류의 기능도 설치 가능  
전역 기능은 항상 사용 가능하며, 사용하기 위해 파일에 임포트 할 필요가 없습니다.  
코어 Node.js 모듈은 설치하지 않아도 되기 때문에 npm install이 필요하지 않지만, 관련된 기능을 사용하려면 임포트 해야 됩니다.  
예시를 보여드리면  
const fs = require('fs');  
“fs” 모듈에서 내보낸 fs객체를 사용할 수 있게 됩니다.  
프로젝트 폴더에npm instal을 실행해 제3자 모듈을 설치하고 임포트 합니다.  
추후 강의에서 다룰 예정이라 지금 당장 이해하실 필요는 없지만, 그 예로  
// Terminal 또는 명령 프롬프트에서는  
   
npm install --save express-session  
// app.js 같은 코드 파일에서는  
   
const sessions = require('express-session');  
]

# 섹션 4: 개선된 개발 워크플로우 및 디버깅 > 45. 자동 재시작을 위한 Nodemon 사용
[
이제 Nodemon 패키지가 설치되었고  
패키지에서 필요로 하는 모든 의존성도 자동으로 설치되었기 때문에  
잘 작동할 것입니다  
그럼 어떻게 사용하는 걸까요?  
Nodemon은 유틸리티 툴로 최종적으로는 node app.js를  
실행하는 이 패키지를 통해  
노드 애플리케이션을 실행할 수 있게 합니다  
동시에 파일들의 변경 내역을 확인하고 우리가 뭔가 변경하는 경우 프로세스를  
재시작시켜 줍니다 즉 이 start 부분을 간단히 변경해서  
node app.js에서 nodemon app.js로 바꾸면  
이 프로젝트에서 nodemon 툴을 검색할 것이고  
우리가 설치했기 때문에 발견할 것입니다  
참고로 여기서 nodemon app.js를 실행할 경우  
이 명령어가 발견되지 않았다는 오류가 뜨게 되는데  
왜냐하면 이 프로젝트에만 설치되어 있고  
머신 전체에 설치되지 않았기 때문입니다 Terminal의 경우  
전역에서 검색할 것입니다  
여기에서는 로컬에서 검색하므로 작동합니다  
이제 npm start를 실행해 보면 노드 서버가 시작되며  
몇몇 추가 정보가 출력될 것이고  
지금 routes.js 파일로 가서 뭔가 편집해 보면  
여기 라인을 하나 추가하고 파일을 저장해 보면 재시작합니다  
굉장히 편한 기능으로 더 이상 수동으로 나가서 재시작하는 데  
시간을 낭비할 필요 없이  
이 패키지가 자동으로 해 주니까요  
]

