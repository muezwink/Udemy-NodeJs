# 자바스크립트 개요
https://developer.mozilla.org/en-US/docs/Learn/JavaScript
https://academind.com/tutorials

# 핵심 구문 복습
01-core-js-syntax.zip  
[JavaScript from Scratch-자바스크립트 처음부터 배우기](https://developer.mozilla.org/en-US/docs/Learn/JavaScript)  
[Various JavaScript Beginner Resources-다양한 자바스크립트 초보자 리소스](https://academind.com/tutorials/)  
[Primitive vs Reference Types-프리미티브 유형과 참조 유형](https://academind.com/tutorials/)  

# let & const
02-let-and-const.zip

# 화살표 함수의 이해
03-arrow-functions.zip
[Arrow Functions and "this"](https://academind.com/tutorials/)  

# 개체, 속성 및 메서드 작업
[Primitive vs Reference Types](https://academind.com/tutorials/reference-vs-primitive-values)

# 배열과 배열 메서드
[Available Array Properties & Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#)

# 배역, 객체 및 참조 유형
[
현대의 JavaScript에는  
반드시 알아야 하는 두 개의 연산자가 있고  
강의에서도 계속 사용할 예정입니다  
바로 레스트(Rest)와 스프레드(Spread) 연산자입니다, 구체적으로 들어가서  
레스트 연산자는 꽤 자주 사용하게 될 것입니다  
새로운 hobby를 추가할 때마다 기존의 배열을  
편집하고 싶지 않다고 해보겠습니다  
대신 기존 값과 새로운 값이 모두 포함된 새로운 배열을 만들고 싶다고 해보겠습니다  
이는 불변성이라 불리며 꽤 자주 등장하는 패턴입니다  
기존의 값을 절대 편집하지 않고  
사본에 변경된 값을 더한 배열로 대체하는 방식입니다  
이 강의에서 자주 사용하게 될 패턴입니다  
복사해서 편집함으로 오류를 피할 수 있고  
기존 객체를 편집하지 않음으로써  
코드를 읽어올 수 없게 되는 일을 방지할 수 있습니다  
배열을 복사하려면 여기 copiedArray를 생성합니다  
몇 가지 기법이 있습니다  
하나는 슬라이스 연산자를 사용하는 것으로  
여기에 copiedArray를 입력하고 node play.js를 실행하면 Sports와 Cooking이 보입니다  
복사되었음을 볼 수 있습니다  
slice는 배열을 복사합니다  
인수를 입력해서 복사하길 원하는 원소의 범위를 제한할 수 있습니다  
인수가 없으면 배열 전체가 복사됩니다  
slice 외에 다른 기법도 있습니다  
대괄호로 새로운 배열을 만들고  
hobbies를 추가해도 됩니다  
이를 실행하면 어떻게 될까요?  
콘솔에 무엇이 표시되는지 보겠습니다  
Enter를 누르면 사본처럼 보입니다 그러나 실제로는 배열 안에  
또 다른 배열이 있는 겁니다  
외부 배열에 하나의 원소만이 있고 그 원소가 바로 내부 배열입니다  
따라서 사본이 아니라 첫 원소가 기존의 배열인 새로운 배열일 뿐입니다  
이는 사본이 아니라 완전히 동일한 객체를 의미합니다  
따라서 우리가 만든 것은  
중첩 배열로 이는 원하던 작업이 아닙니다  
여기서 사용 가능한 스프레드 연산자는 배열 또는  
객체 앞에 추가하는 점 세 개입니다  
이 점 세 개는 +나 -와 같은 연산자로  
연산자 뒤에 오는  
배열이나 객체를 받아서  
원소나 속성을 끄집어냅니다  
따라서 배열의 원소나 객체의 속성을  
스프레드 연산자 주위에 있는 대상에 추가합니다  
이 경우에는 스프레드 연산자에 대괄호가 씌워져 있으므로  
기존의 배열에서 끄집어낸 모든 원소를  
새로운 배열에 추가해 줍니다  
따라서 이 파일을 저장하고 다시 실행하면  
기존 접근법의 중첩 배열이 있던 곳에  
중첩 배열이 없어졌습니다  
대신 배열 하나가 있고 이 배열은 기존 배열의 사본입니다  
스프레드 연산자로 원소를 끄집어내서  
새로운 배열에 하나씩 추가했기 때문입니다  
기존의 배열이나 객체에 이러한 작업을 많이 하게 될 것입니다  
객체에서도 같은 방식으로 작동합니다  
중괄호로 copiedPerson을 만들고 스프레드 연산자를  
점 세 개로 입력하고 기존의 Person을 입력합니다  
이제 copiedPerson을 console.log 하고  
이 파일을 다시 실행하면  
여기에 person의 사본이 나타납니다 객체의 원소를 모두 추출해서  
새로운 객체에 추가했기 때문입니다  
이는 객체와 배열 모두에 적용 가능합니다 그리고 이 구문을  
이 강의에서 자주 사용하겠습니다  
이게 바로 스프레드 연산자입니다  
레스트 연산자도 언급했는데 레스트 연산자는 정 반대입니다  
toArray라는 이름의 화살표 함수가 있다고 해보겠습니다  
arg1, arg2, arg3 인수가 있습니다  
이 인수들을 포함한 배열을 반환하도록 하고 싶습니다  
여기에 등호를 추가해 줍니다  
이 인수들을 포함한 배열을 반환하게 하고자 합니다  
return 대괄호를 입력하고 첫 번째 원소는 arg1,  
두 번째 원소는 arg2, 세 번째 원소는 arg3로 하면 됩니다  
이제 console.log (toArray)를 입력하고  
1, 2, 3,을 각각 인수로 함수에 입력한 다음  
play.js를 실행하면 1, 2, 3 세 개의 원소가 포함된 배열이 보입니다  
제대로 됐습니다 그러나 이는 전혀 유연하지 않습니다  
네 개의 인수를 입력하고 싶다면  
이렇게 호출할 수도 있습니다  
JavaScript는 이를 허용합니다  
그러나 세 개의 인수만으로 작업했기 때문에 추가되지는 않습니다  
이럴 때 레스트 연산자를 활용할 수 있습니다  
... 뒤에 args를 입력합니다  
이렇게 하면 개수에 관계없이  
모든 인수를 가지고 와서  
하나의 배열로 나타냅니다  
여기서 args는 배열이 되며 이를 반환하게 할 수 있습니다  
이제 toArray에 4개의 인수를  
입력하고 다시 실행하면 이제 4개의 인수가 있는  
배열을 얻을 수 있습니다 레스트 연산자는 스프레드 연산자처럼  
세 개의 점으로 되어있으며 사용하는 위치에 따라 정의가 달라집니다  
배열이나 객체에서 원소나 속성을 추출하는 데 사용한다면  
스프레드 연산자입니다  
인수 목록이나 함수에서  
여러 인수를 하나의 배열로 묶는데 사용한다면  
레스트 연산자입니다  
구문으로 보면 동일한 연산자이지만  
사용하는 위치에 따라 이름이 달라집니다  
이 구문은 강의에서 자주 사용하지는 않겠지만 그래도 알아두면 좋습니다  
그러나 원소 또는 속성 추출은 반드시 이해해야 합니다  
이 강의 전반에 걸쳐서  
자주 사용할 구문이기 때문입니다
]

# 스프레드(Spread) 및 레스트(Rest) 연산자의 이해
[차이점](https://chat.openai.com/c/4851a6d4-70ee-4c6f-b7ce-03c93a7efd7b)  

# Destructuring (구조분해)
[배열과 객체의 구조분해, 객체를 인자로 받는 함수에서의 구조분해](https://chat.openai.com/c/2fbe5a80-9873-40cd-85eb-05e1efe6cc49)

# 비동기 코드와 프로미스
[
다시 play.js 파일을 지웠습니다
빠르게 복습 모듈을 마치고 다른 핵심 개념인
비동기화 코드를 다루는 방법을 배우기 위해서입니다
이를 위해 먼저 비동기화 코드가 무엇인지부터 이해해야 합니다
Node.js에 구축되어 있는 함수인 타이머 종료 시간을 설정한다고 가정합시다
이 경우 일정 시간 이후 실행 또는 종료되는 함수를 정의하게 됩니다
저는 화살표 함수를 사용하지만
이름이 지정된 함수 등 다른 함수를 사용해도 좋습니다
두 번째 인수는 타이머입니다
2초라고 합시다 밀리초로 표현해야 해서
2초라면 2000 밀리초가 되겠죠
이 안에 간단하게 타이머가 끝났다고 적겠습니다
이제 이 파일을 2초 동안 실행하게 되면
아무 일도 일어나지 않고 타이머가 끝난 것을 볼 수 있습니다
이게 바로 비동기화 코드로 즉시 끝나지 않기 때문에
1 밀리초를 입력했더라도 마찬가지로 비동기화 코드에 해당합니다
아무리 빠르다고 해도 즉시 발생하는 것은 아닙니다
코드 구간에서 예를 들면 console.log
('Hello!'), 그리고 console.log('Hi!')가 있을 때
이 스니펫은 비동기화 코드로 각자가 끝난 뒤 곧바로 실행되지만
기술적으로는 실행되기까지 시간이 좀 소요될 텐데, 하드웨어를 제외하고는
딜레이가 존재하지 않으므로 동기화 코드이고
이것이 비동기화 코드로 즉시 실행되거나 끝나지 않고
짧긴 해도 시간이 소요됐기 때문입니다 이 파일을 이렇게 실행하면
종료되기 전에 Hello!와 Hi!가 아주 짧게나마 나타납니다
왜냐하면 Node.js와 JavaScript는 일반적으로
코드 실행이 종료될 때까지는 이를 멈추지 않기 때문입니다
여기에서는 콜백 함수라고 하는 함수를 인식할 것입니다
즉 함수는 나중에 실행될 것입니다
추후 완료된 이후에 답신하게 됩니다
따라서 여기에서 타이머가 종료된 뒤에 이걸 인지하게 되며
우리는 곧바로 다음 줄로 이동해서
모든 동기화 코드를 실행하고
이게 종료된 뒤에 비동기화 코드가 실행됩니다
그래서 코드에서 Timer is done!이 먼저 출력됐음에도
Hello!와 Hi!를 먼저 보게 되는 것입니다
JavaScript와 특히 Node에서 이 개념은 반드시 이해해 둬야 합니다
정말 중요하기 때문에 강의 전반에 걸쳐 다시 언급하도록 하겠습니다
이제 이걸로 작업하면서
뚜렷하게 하기 위해 2초로 이 값을 올리면
동기화 코드가 실행되는 것을 다시 볼 수 있고
2초가 지난 뒤에 이 코드가 실행됩니다
비동기화 코드로 작업할 때는 이를 다루는 기법들이 여러 가지 있습니다
콜백 함수는 그중 가장 오래된 함수이며
특히 Node.js에서 자주 보게 될 것입니다
잘못된 건 전혀 아닙니다
그러나 몇 가지 의존성 비동기 작업의 경우 문제에 직면하게 됩니다
여기에서는 타이머를 설정하고 다른 함수 생성을 위해
fetchData라고 하겠습니다
여기에도 타이머를 설정하는데
데이터를 가져오게 되는 데이터베이스 같은 걸
설정하고 싶지 않아, 강의를 진행하면서 다루게 되니 걱정 마세요
여기에 또 다른 타이머는 1.5초 정도로 하겠습니다
그리고 여기 fetchData에서 저는 이 내부 타이머가 끝났을 때
뭔가를 실행시킬 필요가 있습니다
여기서 저는 callback이라고 지정할 인수를 입력합니다
이 인수는 타이머가 끝난 뒤에 제가 내부 함수로 호출할 함수이기 때문입니다
여기에서 Done!이라는 값을 입력하고
fetchData를 사용하는 장소가 여기
setTime 내부라고 하고 호출하겠습니다
이렇게 fetchData를 호출합니다 여기에서 또 다른 콜백이 필요합니다
실행하게 되면 여기에서 함수를 콜백 하기 위해
텍스트가 전달되어 텍스트를 입력하고
그 텍스트를 console.log 할 수 있죠
조금 혼란스러울 수 있는데
저는 저만의 함수를 생성하는 중으로, 콜백을 받음으로써
이 내부 타이머가 다른 곳에서 완료되었을 때
실행되는 함수를 정의할 수 있습니다
그러니까 여기에서 이 함수는 콜백으로 전달되는 것입니다
그리고 여기서 그 함수를 실행합니다
이제 이걸 저장하고 실행하면
2초가 지난 뒤에 Timer is done!,
그리고 다시 1.5초 후에 Done!이 보입니다
만약 중첩된 비동기화 호출이 여기에서처럼 몇 개 존재하는 경우
우리는 콜백 시점에서 점점 더 깊게 들어가게 됩니다
그렇기 때문에 프로미스(Promise)라는 기능을 Node.js에서 사용할 수 있습니다
이미 프로미스가 사용된 제3자 패키지를 자주 사용할 것입니다
따라서 여기에서 보여드릴 구문은 직접 작성할 일은 거의 없습니다
내부 패키지가 진행하게 되겠죠
그래도 알아두면 좋습니다 fetchData 함수 내부에
프로미스를 생성한다고 해봅시다
상수 또는 변수로 저장하고
JavaScript 내부에서 생성자를 기반으로
새로운 객체를 생성하는 new 키워드를 사용합니다
만약 생성자 함수의 의미가 전혀 와닿지 않는다면
JavaScript에 관련된 기본 개요 자료를 찾아보세요
생성자 함수는 JavaScript의 핵심 기능이기 때문입니다
여기에서는 JavaScript와 Node.js
내부에 구축된 프로미스 생성자 함수를 사용합니다
이후 resolve와 reject라는 두 가지 인수를 콜백하게 되는데
이름은 자유롭게 붙여도 되고 어쨌든 두 함수가 들어옵니다
첫 번째 함수는 프로미스를 성공적으로 완료하여
성공적으로 해결합니다
두 번째 함수는 거부하게 되는데 예를 들면 에러를 표시하는 거죠
다음으로 비동기화 코드를 안으로 이동시킬 수 있습니다
다시 강조하지만 이건 직접 작성할 일은 거의 없습니다
대부분의 패키지들이 이미 알아서 진행해 주고
완료된 프로미스를 전달하여 배후에서
전부 다 해결해 주지만 지금은 수동으로 진행해 보는 것이죠
콜백 내부에 함수가 있는데
안타깝게도 setTimeout이 프로미스 API를 제공하지 않아
여기에도 콜백을 사용해야 하지만
이제 더 이상 우리가 얻게 되는 콜백 함수를 사용할 수 없고
더 이상 여기에서는 인수를 얻거나 데이터를 가져올 수 없습니다
대신 resolve('Done!')을 입력하여 성공적으로 결괏값을
반환합니다 이제 fetchData에서
프로미스를 정의한 뒤에는 반환하기만 하면 됩니다
이건 동기화 코드라는 걸 기억해 주세요
이제 이건 프로미스 내부의 코드가 실행되기 전에
프로미스가 생성된 직후 반환될 텐데,
이 함수를 호출하고 이 타이머의 Done!이 완료되고 얼마 후
일어날 일입니다
이제 프로미스를 여기로 반환하고 fetchData를 호출하는 자리에
더 이상 콜백을 전달하지는 않지만 프로미스 상에서
호출할 수 있는 then을 사용하고 프로미스를 반환할 수 있습니다
이건 단순히 콜백 함수를 여기에 정의해서
프로미스가 해결된 뒤에 실행되도록 합니다
그런 프로미스가 여러 개 있을 때 장점은 뭐가 있을까요?
여기에 fetchData를 다시 호출했다면
이런 식으로 then을 사용할 필요가 없습니다
이 경우 다시 콜백이 중첩되겠죠
대신 프로미스 내부에 블록이 프로미스의 일부인 경우
간단히 새로운 프로미스를 반환하고
다음 then 블록을 이전 블록 다음에 추가할 수 있습니다
이렇게 하면 then 블록이 연쇄적으로 구성되어
첫 번째 프로미스 다음에는 이 블록이 호출되고
then 블록 내부에서 다른 프로미스를 반환하게 됩니다
프로미스를 전달하지 않는다고 해도 then 블록은 이걸 반환하는 대신
즉시 해결되는 프로미스로 전환하게 됩니다
그리고 여기 이 프로미스에 관련된 다른 then 블록을 추가하면
무한히 중첩된 콜백을 두는 것보다 훨씬 읽기 편합니다
이걸 실행해 보면 Hello!, Hi!, Timer is done!이 보입니다
Done!은 두 번 나타나는데
fetchData를 두 번 호출하기 때문입니다
처음 접하게 되면 정리하기에 좀 어려울 수 있습니다
이 강의를 진행하면서 계속 다시 사용하면
좀 더 명확해질 것입니다
재차 말씀드리지만 이 코드는 직접 작성할 일이 거의 없지만
우리의 비동기화 코드를 더 잘 관리할 수 있는 핵심 개념입니다
이를 관리하는 다른 방법이 존재하는데
현대 JavaScript에서는 async, await와 특수
키워드를 사용할 수 있으며 강의 후반부에서
따로 설명드리겠습니다
이 구문보다 더 복잡할 수 있어 여기에서 소개해 드리고 싶진 않습니다
한 번에 너무 많은 새 기능을 소개해 드리고
싶지는 않으므로 이것 하나만 하겠습니다
하지만 비동기 코드는 이해해 두셔야 합니다
이 시점에 완전히 이해하고 계시지 않아도 괜찮습니다
강의 내내 자주 등장할 것입니다
왜냐하면 Node.js에는 여러 비동기화 이벤트가 있으며
있으며 저도 여러 번 설명할 것이기 때문입니다
프로미스도 다시 설명하니
현재로서는 최소한 한 번 보고
작동 방식과 활용 방법을 이해할 기회를 드리고 싶습니다
]

# 템플릿 리터럴 
[
템플릿 리터럴(Template literals)이라는 기능을 종종 사용하게 될 거예요.  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
문자열을 작성하는 다른 방법입니다.
큰따옴표나 작은따옴표를 사용해
'A String'
혹은
"Another string"
와 같은 방식으로 표현하거나,
백틱(`)을 사용해
`Another way of writing strings`
와 같은 방식으로 표현합니다.
왜 문자열을 이런 방식으로 표현할까요?
이 구문을 사용하면, 문자열에 다양하게 데이터를 추가할 수 있어요.
const name = "Max";
const age = 29;
console.log(`My name is ${name} and I am ${age} years old.`);
처럼요.
기존의 문자열 결합 방식보다 짧고 읽기 쉽습니다.
const name = "Max";
const age = 29;
console.log("My name is " + name + " and I am " + age + " years old.");
와 비교해서 말이죠.
]

# 유용한 자료 및 링크
[MDN JavaScript 튜토리얼](https://developer.mozilla.org/en-US/docs/Learn/JavaScript)
[Academind JS 자료](https://academind.com/learn/javascript)

# Node 서버 생성
[nodejs의 코어모듈과 라이브러리](https://chat.openai.com/c/0b4047bc-4a2b-4fa6-a815-78a5d4d99466)